var tipuesearch = {"pages": [{'title': '首頁', 'text': '\n 這學期千辛萬苦地走過，在茫茫大海中找尋課業的答案，就像徐徐的海浪，看似溫柔卻蘊含風暴，起起伏伏就像我孤獨的心，霧茫茫的夜晚，在網路上漂泊，山窮水復疑無路，柳暗花明在高處，原來答案都在網路上，用最佳的關鍵字找尋最合適的答案，這也是我這學期最有收穫的。 \n 不論遇到何種問題，針對所做的動作，針對問題去做提問，不要有模菱兩可或多方向猜想，以致老師不好解決問題，而我也從中學習到了如何編輯自己的網頁，及githud、kaggle等，好好運用免費資源去最大化學習效率，日後也要繼續加強英文才能運用外國網站去賺錢。', 'tags': '', 'url': '首頁.html'}, {'title': '錯誤排除紀錄', 'text': '', 'tags': '', 'url': '錯誤排除紀錄.html'}, {'title': '有問題就到gitter問老師', 'text': '', 'tags': '', 'url': '有問題就到gitter問老師.html'}, {'title': '問就對了', 'text': '', 'tags': '', 'url': '問就對了.html'}, {'title': 'python wsgi.py', 'text': '不可以多一個空格 \n \n', 'tags': '', 'url': 'python wsgi.py.html'}, {'title': '先git add .\xa0 \xa0在commit', 'text': '\n', 'tags': '', 'url': '先git add .\xa0 \xa0在commit.html'}, {'title': 'HW2', 'text': '', 'tags': '', 'url': 'HW2.html'}, {'title': '作業2-1', 'text': 'https://www.kaggle.com/chentinghan/cp2020-hw2/edit \n 方法一 : \n import urllib.request\n#導入urllib.request\ntarget_url = "https://nfulist.herokuapp.com/?semester=1091&courseno=0776"\n#設target_url = "網址"\ncp1b = []\n#設cp1b=數列\nfor line in urllib.request.urlopen(target_url):\n#重複打開target_url的迴圈定義line\n    cp1b.append(int(line.decode(\'utf-8\').rstrip()))\n    #把line重新編碼加進cp1b(數列)   註:rstrip()刪除字尾符號\nprint(cp1b) \n \n \n \n 方法二: \n \n \n \n \n from random import shuffle #導入隨機洗牌\nlist  = [40523138,40523148,40723217,40728238,40823148,40823152,40923201,40923202,40923203,40923204,40923205,\n40923206,40923207,40923208,40923209,40923210,40923211,40923212,40923213,40923214,40923216,40923217,40923218,\n40923219,40923220,40923221,40923223,40923224,40923225,40923226,40923227,40923228,40923229,40923230,40923231,\n40923232,40923233,40923234,40923235,40923236,40923237,40923238,40923239,40923240,40923241,40923242,40923243,\n40923244,40923245,40923246,40923247,40923248,40923249,40923250,40923251,40923252,40923253] \n#列表[]\nshuffle(list) #shuffle=洗牌\nn=5\nm = int(len(list)/n) \nlist2 = [] \nfor i in range(0, len(list), m): #range()是一个函数， for i in range () 就是给i赋值： \n    list2.append(list[i:i+m]) \nprint(list2) \n \n \n \n \n \n \n', 'tags': '', 'url': '作業2-1.html'}, {'title': '作業2-2', 'text': '還沒有成果', 'tags': '', 'url': '作業2-2.html'}, {'title': '作業2-3', 'text': '沒得參考 \n', 'tags': '', 'url': '作業2-3.html'}, {'title': 'HW3', 'text': '', 'tags': '', 'url': 'HW3.html'}, {'title': '20 Element Search', 'text': 'Exercise 20 (and Solution) \n Write a function that takes an ordered list of numbers (a list where the elements are in order from smallest to largest) and another number. The function decides whether or not the given number is inside the list and returns (then prints) an appropriate boolean. \n 練習20（和解決方案） 編寫一個函數，該函數接受一個有序的數字列表（一個元素從最小到最大的順序列表）和另一個數字。 該函數確定給定的數字是否在列表中，並返回（然後打印）適當的布爾值。 \n Extras: \n 附加功能 \n Use binary search.使用二進制搜索。 Discussion \n Topics: \n Booleans - True and False Equality testing Binary search 討論區 話題： \n 布爾值-對與錯 平等測試 二進制搜索 \n Booleans \n When you are writing programs, there is often a time when you need to make a decision about something based on the truthfulness of something else. Basically, you need to make a decision based on whether something is TRUE or something is FALSE. \n An obvious example is when using conditionals: \n 布爾值 在編寫程序時，通常會需要根據其他事物的真實性來做出決策。 基本上，您需要根據某物是TRUE還是FALSE來做出決定。 \n 一個明顯的例子是使用條件句時： \n \n michele_age = 22\n  truth_value = michele_age > 17\n  if (truth_value):\n    print("Michele can see a rated R movie") \n \n (We talked about this idea of conditionals in a previous post.) \n But what is happening behind the scenes is that the statement michele_age > 17 is being evaluated into a type that is either True or False. This is then getting stored inside the variable truth_value, and then the decision is being made inside the conditional. \n Here is another example: \n （我們在上一篇文章中談到了條件式的想法。） \n 但是幕後發生的事情是，語句michele_age> 17正在被評估為True或False類型。 然後將其存儲在變量true_value中，然後在條件中進行決策。 \n 這是另一個示例： \n  while True:\n    age = input("How old are you? ")\n    if age >= 17: \n      print("can see a rated R movie")\n    elif age < 17 and age > 12:\n      print("can see a rated PG-13 movie")\n    else: \n      print("can only see rated PG movies") \n \n \n What the while True statement does at the beginning of the code segment is continue asking for an age and printing a response - it never stops. (To stop it, press CTRL-C in a terminal or in the Python shell). \n These types - True and False are called boolean types or boolean variables. They can only take on two values, either True or False. \n For more extensive reading on Python booleans, take a look at these resources. \n \n 而True語句在代碼段的開頭所做的是繼續詢問年齡並打印響應-它永遠不會停止。 （要停止它，請在終端或Python Shell中按CTRL-C）。 這些類型-True和False稱為布爾類型或布爾變量。 它們只能採用兩個值，即True或False。 \n 有關Python布爾值的更多詳細信息，請查看這些資源。 \n \n Equality testing on strings \n 字符串相等性測試 \n \n Scenarios come up where you need to test if things are equal to each other - numbers or strings or something else. We covered this idea in a previous post, but it is worth returning to again, this time for strings. \n Good thing it’s easy! \n Remember, comparing numbers for equality is done with an == sign, like so: \n \n  age = 21\n  if age == 21:\n    print("You are 21!")\n  elif age > 21:\n    print("You\'re old.")\n  else:\n    print("Young one!") \n \n 出現場景時，您需要測試事物是否彼此相等-數字或字符串或其他。 我們在上一篇文章中介紹了這個想法，但是這次還是值得再次討論的。 \n 好東西很容易！ \n 請記住，比較數字是否相等是使用==符號完成的，如下所示： \n \n   password = "unsafepassword"\n  if password == "unsafepassword":\n    print("You may enter.")\n  else:\n    print("Try again!") \n Turns out, comparing strings is equally (hehe..) simple, using a == to check for equality and != to check for inequality. \n 事實證明，使用==來檢查是否相等，使用！=來檢查不相等，比較字符串同樣簡單（hehe ..）。 \n \n Or, a more practical password-checking piece of code: \n \n \n real_password = "unsafepassword"\n  user_password = input("Enter the password: ")\n  while user_password != real_password:\n    user_password = input("Enter the password: ")\n  print("You may enter!") \n \n 或者，使用更實用的密碼檢查代碼： \n \n Binary search \n \n \n 二進制搜索 \n \n There are a number of ways to search for elements in a list, and there is no one correct way to do so. The point of this exercise is to get you thinking about possible ways to search for elements in the list, in an entire sequence of exercises about lists, searching, and sorting. This exercise might seem silly and easy at first, but the more you dive into this topic, the more difficult it becomes. \n 有多種方法可以搜索列表中的元素，但沒有一種正確的方法可以搜索列表中的元素。 該練習的目的是讓您思考有關列表，搜索和排序的整個練習序列中搜索列表中元素的可能方法。 剛開始時，此練習可能看起來很愚蠢且容易，但是您越深入該主題，就越困難。 \n \n The word “binary” means there are two choices (in computers, often this is 0 or 1, but it really means any choice between two things). “Search” is to look for something. So the main idea behind binary search is to look for something in a way that gives you a decision tree for where to look, containing two choices. Let me give you an example: \n “二進制”一詞表示有兩種選擇（在計算機中，通常是0或1，但實際上表示在兩種情況之間可以選擇）。 “搜索”是尋找東西。 因此，二進制搜索背後的主要思想是以某種方式查找內容，該方式可以為您提供決策樹，以查找位置，其中包含兩個選擇。 讓我舉一個例子： \n Let’s take the list a = [1, 3, 5, 30, 42, 43, 500]. It is an “ordered list”, or a list where the elements in the list go from smaller to larger. Let’s say we want to know whether the element 9 is in the list or not. Here is what we do: \n 讓我們以列表= [1、3、5、30、42、43、500]為例。 它是一個“有序列表”，或者是列表中元素從小到大的列表。 假設我們想知道元素9是否在列表中。 這是我們的工作： \n Look at the middle element in the list - it is ‘30’. * ‘9 < 30’, so let us ignore the elements to the right of ‘30’. The new list we are looking at is now [1, 3, 5]. Look at the middle element in this new list - it is 3. ‘9 > 3’, so ignore the elements to the left of 3. The new list we are looking at is [5]. The list has one element and it is not 9. 9 is not in the list. 查看列表中的中間元素-它是“ 30”。 *“ 9 <30”，因此我們忽略“ 30”右側的元素。 現在，我們正在查看的新列表為[1、3、5]。 看一下這個新列表的中間元素-是3。 ‘9> 3’，因此忽略3左側的元素。 我們正在查看的新列表為[5]。 該列表只有一個元素，而不是9。 9不在列表中。 \n What the example shows is that in an ordered list, knowing how the element you are looking for compares to another element in the list splits the list in two - one half where the element can be, and one where it definitely cannot be. In the case where our list contains millions of elements, knowing that we can cut the “search space” in half is a great increase in efficiency. \n 該示例顯示的是，在有序列表中，知道要查找的元素與列表中另一個元素的比較方式，將列表分為兩部分-元素可以位於其中一半，而絕對不能位於其中。 在我們的列表包含數百萬個元素的情況下，知道我們可以將“搜索空間”削減一半，這將大大提高效率。 \n When you are writing the solution, first try to write it without binary search. Then when you want to try implementing binary search, write a separate function. In the solution I will give an example for how to write a binary search in Python. \n 在編寫解決方案時，請首先嘗試在不進行二進制搜索的情況下編寫它。 然後，當您想嘗試實現二進制搜索時，編寫一個單獨的函數。 在解決方案中，我將給出一個示例，說明如何使用Python編寫二進制搜索。 \n', 'tags': '', 'url': '20 Element Search.html'}, {'title': '21 Write To A File', 'text': "Exercise 21 (and \xa0 Solution ) \n 練習21（和解決方案） \n Take the code from the \xa0 How To Decode A Website \xa0 exercise (if you didn’t do it or just want to play with some different code, use the code from the \xa0 solution ), and instead of printing the results to a screen, write the results to a txt file. In your code, just make up a name for the file you are saving to. \n 從“如何解碼網站”練習中獲取代碼（如果您沒有這樣做，或者只是想使用一些不同的代碼，請使用解決方案中的代碼），而不是將結果打印到屏幕上，而是將結果寫在屏幕上到txt文件。在您的代碼中，只需為要保存到的文件命名。 \n Extras: \n \n Ask the user to specify the name of the output file that will be saved. \n \n 附加功能： 要求用戶指定將要保存的輸出文件的名稱。 \n Discussion \n 討論區 \n Topics: \n \n Writing to a file \n Gotchas and warnings \n \n 話題： 寫入文件  \n 陷阱和警告 \n Saving to a file \n 保存到文件 \n Python makes it very easy to write to a file. Depending on what kind of file you want to write to and what kind of data you are writing, your options are plenty. I will show you the simplest form of writing to a file - writing plain text to a plain old text file. In other words, writing a string to a\xa0 .txt \xa0 file. \n Python使寫入文件變得非常容易。根據要寫入的文件類型和要寫入的數據類型，您有很多選擇。我將向您展示最簡單的寫入文件的形式-將純文本寫入純文本文件。換句話說，將字符串寫入.txt文件。 \n The code looks like this: \n with open('file_to_save.txt', 'w') as open_file:\n    open_file.write('A string to write') \n \n 代碼如下： \n  open_file = open('file_to_save.txt', 'w')\n  open_file.write('A string to write')\n  open_file.close() \n \n An alternate way of writing the same code is like so: \n 編寫相同代碼的另一種方法是這樣的： \n The first is considered better programming practice, but the second might explain a little bit better what is going on in the first code sample. \n 第一種被認為是更好的編程實踐，但是第二種可能會更好地解釋第一個代碼示例中發生的事情。 \n Let’s go through line by line. \n 讓我們逐行進行。 The\xa0 with open('file_to_save.txt', 'w') as open_file \xa0 syntax is new for us - all it means is that inside the code block indented underneath, there will be a variable called \xa0 open_file \xa0 that will represent the file object. You can pick any name for this file - it is just a variable name. The \xa0 open() \xa0 function takes two arguments - the first is the name of a file as a string (if the file does not exist, Python will create it), and a second argument that represents \xa0 how \xa0 the file should be opened. There are a few ways you can open files (read all about it \xa0 at the official Python documentation ), but in short, there are two most common ones: \xa0 'r' \xa0 and \xa0 'w' . \xa0 'r' \xa0 stands for “read only” and \xa0 'w' \xa0 stands for “write only” (you can open for both read and write using \xa0 'r+' ). You should tell Python which way you want to open the file - you don’t want to modify a file you are only looking at, and opening a file with \xa0 'w' \xa0 when you want to only read it will overwrite the old file. \n open（'file_to_save.txt'，'w'）作為open_file語法對我們來說是新的-這意味著在縮進的代碼塊內將有一個名為open_file的變量，它將表示文件對象。您可以為此文件選擇任何名稱-它只是一個變量名。 open（）函數有兩個參數-第一個參數是字符串形式的文件名（如果文件不存在，Python會創建它），第二個參數表示應如何打開文件。您可以通過幾種方式打開文件（在Python官方文檔中了解所有相關信息），簡而言之，有兩種最常見的文件：“ r”和“ w”。 “ r”代表“只讀”，“ w”代表“僅寫”（您可以使用“ r +”打開以進行讀寫）。您應該告訴Python您想以哪種方式打開文件-您不想修改僅查看的文件，而只想讀的文件以'w'打開將覆蓋舊文件。 \n \n When you open a file, it will look for it in the same directory as the Python program. If there is no file with that name, Python will create a file in that directory with the given name. To look for files in other directories, use the \xa0 ../ \xa0 notation to move up and down directories as necessary. \n \n 當您打開文件時，它將在與Python程序相同的目錄中查找。如果沒有使用該名稱的文件，Python將在該目錄中使用給定名稱創建一個文件。要在其他目錄中查找文件，請根據需要使用../符號在目錄中上移和下移。 \n As soon as the program exists the\xa0 with \xa0 code block for any reason, it will close the file. In the second code example case, I created the file object by opening the file and saving the object to my variable \xa0 open_file . I then had to remember to close the file manually at the end of my program. This is considered worse programming practice, because in case there is an error in the program and it terminates before hitting the \xa0 .close() \xa0 statement, there will be a floating open file object somewhere in memory. You do this enough times and it becomes a problem, \n 一旦程序由於某種原因存在with代碼塊，它將關閉文件。在第二個代碼示例中，我通過打開文件並將對象保存到變量open_file來創建文件對象。然後，我必須記住在程序結束時手動關閉文件。這被認為是較差的編程習慣，因為如果程序中有錯誤並且在命中.close（）語句之前終止，則在內存中的某個位置將有一個浮動的打開文件對象。您這樣做足夠的時間，這就會成為問題， \n especially for production environments. For playing around with Python, this is not usually a problem, but why not learn how to program correctly the first time? \n 特別是對於生產環境。對於使用Python來說，這通常不是問題，但是為什麼不第一次學習如何正確編程呢？ \n The\xa0 write() \xa0 portion is simple - call \xa0 .write() \xa0 with a string (if something is not a string, turn it into a string first), and it will write to the end of the file. \n write（）部分很簡單-使用字符串調用.write（）（如果不是字符串，請先將其轉換為字符串），然後它將寫入文件的末尾。 \n When the program exists the\xa0 with \xa0 statement, the file will automatically be saved. In fact, every time after a \xa0 .write() \xa0 statement, the file will be automatically saved. \n 當程序存在with語句時，該文件將自動保存。實際上，每次執行.write（）語句後，該文件都會自動保存。 \n Gotchas and Warnings \n 陷阱和警告 \n This all seems simple enough, but there are a few caveats to the file-writing endeavor. \n 這一切似乎很簡單，但是文件編寫工作有一些警告。 \n \n You always want to make sure you close a file. The easiest strategy for this is explained above - use the \xa0 with \xa0 statement rather than trying to manually remember to \xa0 .close() \xa0 the file. \n Opening a file for writing with \xa0 'w' \xa0 will overwrite any file that currently exists with that name. If you have previously written data to that file, it is now gone as soon as Python opens it. \n You can write \xa0 any \xa0 kind of object to any kind of file in Python, as long as you specify the correct format. The simplest thing to do is to write strings to a \xa0 .txt \xa0 file. But remember - you have to convert numbers or objects into strings before you write them to a file. In a later exercise, we’ll talk about writing to other formats. \n \n 您始終要確保關閉文件。上面已說明了最簡單的策略-使用with語句，而不是嘗試手動記住.close（）文件。 打開要寫入的文件“ w”將覆蓋該名稱當前存在的任何文件。如果您之前已將數據寫入該文件，則Python打開後立即消失。 只要指定正確的格式，就可以在Python中將任何類型的對象寫入任何類型的文件。最簡單的方法是將字符串寫入.txt文件。但是請記住-在將數字或對象寫入文件之前，必須將其轉換為字符串。在以後的練習中，我們將討論編寫其他格式的內容。 \n The best way to remember the caveats is to explore them yourself, so have at it! \n 記住警告的最好方法是親自探索它們，因此，快來試試吧！", 'tags': '', 'url': '21 Write To A File.html'}, {'title': '22 Read From File', 'text': "Exercise 22 (and \xa0 Solution ) \n 練習22（和解決方案） 給定一個.txt文件，其中列出了一堆名字 \n Given a\xa0 .txt \xa0 file that has a list of a bunch of names, count how many of each name there are in the file, and print out the results to the screen. I have a \xa0 .txt \xa0 file for you, if you want to \xa0 use it ! \n 給定一個具有一堆名稱列表的.txt文件，請計算該文件中每個名稱的數量，然後將結果打印到屏幕上。如果您想使用它，我有一個.txt文件！ \n Extra: \n 額外： \n \n Instead of using the \xa0 .txt \xa0 file from above (or instead of, if you want the challenge), take \xa0 this \xa0 .txt \xa0 file , and count how many of each “category” of each image there are. This text file is actually a list of files corresponding to the \xa0 SUN database \xa0 scene recognition database, and lists the file directory hierarchy for the images. Once you take a look at the first line or two of the file, it will be clear which part represents the scene category. To do this, you’re going to have to remember a bit about string parsing in Python 3. I talked a little bit about it \xa0 in this post . \n \n 不要使用上方的.txt文件（或者，如果您想挑戰，也可以使用該.txt文件），請使用此.txt文件，併計算每個圖像的每個“類別”有多少個。該文本文件實際上是與SUN數據庫場景識別數據庫相對應的文件的列表，並且列出了圖像的文件目錄層次結構。查看文件的第一行或第二行後，將很清楚哪個部分代表場景類別。為此，您將需要記住一些有關Python 3中的字符串解析的知識。我在本文中對此進行了一些討論。 \n Discussion \n 討論區 \n Topics: \n \n Reading a file \n Dictionaries \n \n 話題： 讀取文件 辭典 \n Reading a File \n 讀取文件 \n Reading a file is very analogous to writing a file, as\xa0 I discussed before in Exercise 21 . But, the best source is always the \xa0 official Python 3.3 documentation . \n 正如我之前在練習21中所討論的那樣，讀取文件與寫入文件非常相似。但是，最好的來源始終是Python 3.3官方文檔。 \n Simply, reading to a file takes two steps: \n \n Opening the file for reading \n Read! \n \n 簡單來說，讀取文件需要兩個步驟： 打開文件進行讀取 讀！ \n Opening a file for reading is the same as opening for writing, just using a different flag: \n with open('file_to_read.txt', 'r') as open_file:\n    all_text = open_file.read() \n \n 打開文件進行讀取與打開文件相同，只是使用一個不同的標誌： Note how the\xa0 'r' \xa0 flag stands for “read”. The code sample from above reads the entire \xa0 open_file \xa0 all at once into the \xa0 all_text \xa0 variable. But, this means that we now have a long string in \xa0 all_text \xa0 that can then be manipulated in Python using any string methods you want. \n 注意“ r”標誌代表“ read”。上面的代碼示例將整個open_file一次全部讀取到all_text變量中。但是，這意味著我們現在在all_text中擁有一個長字符串，然後可以使用所需的任何字符串方法在Python中對其進行操作。 \n Another way of reading data from the file is line by line: \n with open('file_to_read.txt', 'r') as open_file:\n  \tline = open_file.readline()\n  \twhile line:\n    \tprint(line)\n    \tline = open_file.readline() \n 從文件讀取數據的另一種方法是逐行： Instead of\xa0 print(line) , you can imagine doing anything you want to the line of text… If you save it to a variable, you have a string that you can then use something like \xa0 .strip() \xa0 or \xa0 .split() \xa0 with. \n 代替print（line），您可以想像對文本行進行任何操作……如果將其保存到變量中，則可以使用一個字符串，然後可以使用.strip（）或.split（）之類的東西。 \n Dictionaries \n 辭典 \n Dictionaries are Python’s way of associating two pieces of data together. The\xa0 official documentation \xa0 says it all. \n student_scores = {'Adama': 100, 'Starbuck': 75, 'Apollo': 80, 'Athena': 85, 'Agathon': 90}\n \n 字典是Python將兩種數據關聯在一起的一種方式。官方文檔說明了一切。 \n The strings (or whatever happens to the left of the\xa0 : \xa0 sign), are called \xa0 keys . When I want to access the \xa0 values \xa0 (the things to the right of the \xa0 : \xa0 sign), I need to ask the dictionary for the value associated with the key: \n adama_score = student_scores['Adama'] \n \n 字符串（或：符號左側發生的任何事情）稱為鍵。當我想訪問值（：符號右邊的東西）時，我需要向字典查詢與鍵關聯的值： You can then modify the score and save it back to the dictionary: \n  adama_score = student_scores['Adama']\n  adama_score += 100\t% adama_score is now 200. This doesn't change the dictionary value\n  student_scores['Adama'] = adama_score\t\t% the score in the dictionary is now updated \n \n 然後，您可以修改分數並將其保存回字典： I can’t ask the dictionary for the key associated with a value, but I can get a list of all the keys, and the same for all the values: \n  all_scores = student_scores.keys()\n  all_names = student_scores.values() \n \n 我無法向字典詢問與某個值相關聯的鍵，但是我可以獲得所有鍵的列表，並且所有值都相同： I can use the\xa0 in \xa0 keyword (just like in lists), do \xa0 dictionary comprehensions \xa0 like list comprehensions (these are cool, take a look at the \xa0 official bit about these ), and iterate over the elements in the dictionary (the syntax is just a little bit different). \n for pair in student_scores.items():\n  \tprint(pair) \n 我可以使用in關鍵字（就像在列表中一樣），做字典理解（例如列表理解）（這些很酷，看看有關這些的官方知識），然後遍歷字典中的元素（語法只是一點點）有點不同）。 \n And this prints out pairs of keys and values that look like: \xa0 (Adama, 100) , etc. \n Because dictionaries are not ordered, looping through them does not guarantee the key / value pairs coming out in a particular order. So be careful. \n 這會打印出如下的鍵和值對：（Adama，100），等等。 由於字典沒有順序，因此遍歷字典不能保證鍵/值對以特定順序出現。所以要小心", 'tags': '', 'url': '22 Read From File.html'}, {'title': '23 File Overlap', 'text': '\n Exercise 23 (and \xa0 Solution ) \n 練習23（和解決方案） \n Given two \xa0 .txt \xa0 files that have lists of numbers in them, find the numbers that are overlapping. \xa0 One \xa0 .txt \xa0 file \xa0 has a list of all prime numbers under 1000, and \xa0 the other \xa0 .txt \xa0 file \xa0 has a list of happy numbers up to 1000. \n 給定兩個帶有數字列表的.txt文件，請查找重疊的數字。一個.txt文件包含一個所有1000以下的質數的列表，另一個.txt文件包含一個最大為1000的幸福數字的列表。 \n (If you forgot, prime numbers are numbers that can’t be divided by any other number. And yes, happy numbers are a real thing in mathematics - you can\xa0 look it up on Wikipedia . The explanation is easier with an example, which I will describe below.) \n （如果您忘記了，質數是不能除以任何其他數字的數字。是的，快樂數是數學中的真實事物-您可以在Wikipedia上查找它。通過一個例子可以更容易地解釋這一點，我將在下面進行說明。） \n Discussion \n 討論區 \n You’ll need to stitch together a few ideas of things I’ve previously talked about on this blog, so if you need a refresher in any of these topics, now is your chance! Of course, there are any number of ways to do this exercise, so these are only suggestions. \n 您需要將我之前在此博客上討論過的一些事情融合在一起，因此，如果您需要在這些主題中的任何一個方面進行複習，現在就有機會！當然，有許多方法可以進行此練習，因此這些只是建議。 \n Topics: \n 話題： \n \n Reading a file, in \xa0 Exercise 21 \n Number types and converting to integers from strings, in \xa0 Exercise 1 \n Lists, in \xa0 Exercise 3 \xa0 and \xa0 Exercise 5 \n \n 在練習21中讀取文件 練習1中的數字類型和從字符串轉換為整數 練習3和5中的清單 \n \n \n \n', 'tags': '', 'url': '23 File Overlap.html'}, {'title': 'kaggle', 'text': '', 'tags': '', 'url': 'kaggle.html'}, {'title': '第八周練習', 'text': 'https://www.kaggle.com/chentinghan/w8-cp2020 \n \n', 'tags': '', 'url': '第八周練習.html'}, {'title': '平常練習用', 'text': 'https://www.kaggle.com/chentinghan/python \n', 'tags': '', 'url': '平常練習用.html'}, {'title': 'homework1', 'text': 'https://www.kaggle.com/chentinghan/cp2020w7/edit \n \n', 'tags': '', 'url': 'homework1.html'}, {'title': 'pch 10 Network Devices', 'text': 'Overview \n Network devices vary according to their purpose. In this module, we will discuss various devices, such as hubs, switches, routers, bridges, network adapters, and media. As we discuss the devices, you should pay attention to their uses, their benefits, and their limitations. We will also explore how to install a network adapter. \n 網絡設備根據其用途而有所不同。 在本模塊中，我們將討論各種設備，例如集線器，交換機，路由器，網橋，網絡適配器和媒體。 在討論設備時，您應注意其用途，優點和局限性。 我們還將探討如何安裝網絡適配器。 \n Hub \n Hubs are among the most simplistic networking devices and are used to connect multiple network devices and workstations to each other, thereby forming a network. Hubs are also known as multiport repeaters. A hub works by accepting a signal in one port and rebroadcasting that same signal out to all of its other ports. Standard hubs do not have any “intelligence” (ability to change in response to varying situations or requirements), so we often refer to them as “dumb hubs.” Hubs can be classified as either active or passive. An active hub repeats the signal it receives on all of its ports and amplifies that signal to full strength. Passive hubs only repeat the signal without adding any amplification. Hubs are an older technology that can be used to easily increase the number of ports available, but this can lead to excessive network errors and collisions. There are newer variants of hubs called smart hubs. Smart hubs are essentially active hubs with enhanced feature sets, such as the use of simple network management protocol (SNMP). \n 集線器是最簡單的網絡設備之一，用於將多個網絡設備和工作站相互連接，從而形成一個網絡。集線器也稱為多端口中繼器。集線器通過在一個端口中接收信號並將該信號重新廣播到其所有其他端口來工作。標準集線器沒有任何“智能”（能夠根據不同情況或要求進行更改的能力），因此我們通常將它們稱為“啞集線器”。集線器可以分為主動或被動兩種。活動集線器會在其所有端口上重複接收到的信號，並將該信號放大到最大強度。無源集線器僅重複信號而不增加任何放大。集線器是一種較舊的技術，可用於輕鬆增加可用端口的數量，但這會導致過多的網絡錯誤和衝突。集線器有較新的變體，稱為智能集線器。智能集線器實質上是具有增強功能集（例如，使用簡單網絡管理協議（SNMP））的活動集線器。 \n Three basic types of Ethernet hubs are as follows: \n \n Passive hub – repeats signal with no amplification \n Active hub – repeats signal with amplification \n Smart hub – active hub with enhanced features (ex: SNMP) \n \n 以太網集線器的三種基本類型如下： \n 無源集線器–重複信號而不放大 有源集線器–重複放大信號 智能集線器–具有增強功能的活動集線器（例如：SNMP） \n \n \n Hubs have no inherent security designed within them because they simply rebroadcast all the information received from one port to every other port. Essentially, hubs rely on the connected workstations to only “listen” to the information on their port if that information is specifically addressed to that workstation. When the information is not addressed to it, the workstation is supposed to simply ignore the data. But a network card can be placed into “promiscuous” mode, where it will listen to all traffic, regardless of which workstation that traffic is addressed to. This makes hubs very insecure. \n 集線器內部沒有設計固有的安全性，因為它們只是將從一個端口接收的所有信息重新廣播到另一個端口。 本質上，集線器僅依賴於連接的工作站來“偵聽”其端口上的信息（如果該信息專門針對該工作站）。 當信息沒有發送給它時，工作站應該只是忽略數據。 但是，可以將網卡置於“混雜”模式，在該模式下，網卡將偵聽所有流量，而不管該流量指向哪個工作站。 這使集線器非常不安全。 \n Another drawback of hubs is that they have to share bandwidth, as all devices operate in one collision domain. Therefore, if you have a 100 Mbps hub, but connect four devices to that hub, your devices will effectively be operating at 25 Mbps each. This can lead to huge slowdowns in your network traffic when using a 16-, 24-, or 48-port hub. \n 集線器的另一個缺點是它們必須共享帶寬，因為所有設備都在一個衝突域中運行。 因此，如果您有一個100 Mbps的集線器，但將四個設備連接到該集線器，則每個設備將有效地以25 Mbps的速度運行。 使用16端口，24端口或48端口集線器時，這可能會導致網絡流量大幅下降。 \n \n Bridges \n Because hubs operate with all devices acting in a single collision domain, a network device that could break up that collision domain into smaller units is required to help the network operate more efficiently. For example, if a hub is connected to another hub, they both operate under a single\xa0 collision domain \xa0 . A bridge is used to connect two hubs together, but still keep the hubs’ collision domains separate. This interconnection of multiple network segments together allows networks to scale into large networks without significantly decreasing the performance of that network. Bridges are smarter than hubs; in fact, they actually analyze the source \xa0 media access control (MAC) addresses \xa0 in the frames entering the bridge and populate an internal MAC table based on those addresses. Future routing decisions are based upon those destination MAC addresses. This intelligent forwarding based on the destination MAC address in the frame allows for a decrease in network traffic by only forwarding information to the root hub associated with the network device. Network switches, which we will discuss, are the evolution of hubs and bridges. \n 因為集線器與所有在單個衝突域中起作用的設備一起運行，所以需要一個可以將該衝突域分解為較小單元的網絡設備，以幫助網絡更高效地運行。例如，如果一個集線器連接到另一個集線器，則它們都在單個衝突域下運行。橋用於將兩個集線器連接在一起，但仍將集線器的衝突域分開。多個網段的這種互連在一起使網絡可以擴展為大型網絡，而不會顯著降低該網絡的性能。橋比集線器更智能；實際上，他們實際上是分析進入網橋的幀中的源媒體訪問控制（MAC）地址，並根據這些地址填充內部MAC表。未來的路由決策將基於那些目標MAC地址。通過僅將信息轉發到與網絡設備關聯的根集線器，基於幀中目標MAC地址的智能轉發可減少網絡流量。我們將討論的網絡交換機是集線器和網橋的演進。 \n Switches \n Switches are used to connect multiple network segments together, whether they connect from switch to switch, or switch to workstation. Each port on a switch acts as its own collision domain. A switch is an evolution from a hub and bridge. Essentially, each port on a switch operates as if it were a hub with a bridge connecting the ports of the hub to the workstation, thereby reducing the chance of a collision on the network to zero. \n 交換機用於將多個網段連接在一起，無論它們是從交換機到交換機還是從工作站到工作站。 交換機上的每個端口都充當其自己的衝突域。 交換機是集線器和網橋的演進。 本質上，交換機上的每個端口都好像是集線器一樣工作，並具有將集線器的端口連接到工作站的網橋，從而將網絡衝突的可能性降低到零。 \n Switches are intelligent devices that make forwarding decisions based upon the MAC addresses they learn and place in their MAC tables. A switch analyzes the source MAC addresses in frames as they enter the switch, and then populates the switch’s internal MAC table with the addresses to match them with the switch ports. This allows the switch to forward the frame only to the correct device on a single switch port, thereby increasing security and network speed. \n 交換機是智能設備，它們根據其學習到的MAC地址並放置在其MAC表中來做出轉發決策。 交換機在輸入源MAC地址時會分析它們進入交換機的幀，然後用地址填充交換機的內部MAC表，以使其與交換機端口匹配。 這允許交換機僅將幀轉發到單個交換機端口上的正確設備，從而提高安全性和網絡速度。 \n If a switch receives a frame but does not have the destination MAC address in its forwarding table, it will flood the frame to all ports except the source to solicit the location of the destination MAC address. Switches break up collision domains but create \xa0 broadcast domains \xa0 . \n 如果交換機接收到幀，但在其轉發表中沒有目標MAC地址，則它將將該幀泛洪到除源之外的所有端口上，以請求目標MAC地址的位置。 交換器分解衝突域，但創建廣播域。 \n Security is increased because only the device to which the information is addressed can receive a copy, regardless of whether the card is in “promiscuous” mode. This is similar in operation to an old-fashioned telephone operator switchboard. If the information isn’t addressed to your port, your port won’t receive the information. Also, because each port is in its own collision domain, the network speed is increased. Regardless of how many devices are on the network, each switch port has full-speed operations, so for a 100 Mbps switch, each device operates at 100 Mbps. \n 安全性提高了，因為無論信息卡是否處於“混雜”模式，只有信息所針對的設備才能收到副本。 這在操作上類似於老式的電話接線員總機。 如果信息未發送到您的端口，則您的端口將不會收到該信息。 另外，由於每個端口都在其自己的衝突域中，因此網絡速度得以提高。 無論網絡上有多少設備，每個交換機端口都可以全速運行，因此對於100 Mbps交換機，每個設備都以100 Mbps的速度運行。 \n \n Routers \n Routers move data packets (layer 3), as opposed to switches (layer 2), which move frames. Routers separate network segments based on IP addressing and will only forward packets out of the segment when configured to do so. This design breaks up broadcast domains created by switches. It is up to the network professional to configure the router to connect different networks together and perform intelligent routing decisions. A router is most closely associated with a computer in that it has a processor and a sophisticated OS. The router compares the IP address of the source and destination of the packet and forwards traffic to/from a network based on this logical address (IPv4 and IPv6 addresses, for example). Routers are typically feature-rich devices and support a wide range of interface types, including unshielded twisted pair, fiber optic, and coaxial cable connections. Like a switch, each port on a router is a separate collision domain. Using access control lists, routers have the ability to block access to networks based on ports or addresses. This blocking adds to the network’s security. \n 路由器移動數據包（第3層），而交換機移動第2層（幀）。路由器根據IP地址將網段分開，並且僅在配置時將數據包轉發出網段。這種設計可以分解由交換機創建的廣播域。由網絡專業人員決定將路由器配置為將不同的網絡連接在一起並執行智能路由決策。路由器與計算機的關係最為密切，因為它具有處理器和完善的操作系統。路由器比較數據包源和目標的IP地址，並基於此邏輯地址（例如，IPv4和IPv6地址）將流量轉發到網絡或從網絡轉發流量。路由器通常是功能豐富的設備，並支持多種接口類型，包括非屏蔽雙絞線，光纖和同軸電纜連接。像交換機一樣，路由器上的每個端口都是一個單獨的衝突域。使用訪問控制列表，路由器可以根據端口或地址阻止對網絡的訪問。這種阻止會增加網絡的安全性。 \n \n Network Adapter \n The network adapter is used to connect a workstation to the network through the use of media. The network adapter can be built in to the motherboard of the device in several ways: \n 網絡適配器用於通過使用介質將工作站連接到網絡。 可以通過幾種方式將網絡適配器內置到設備的主板中： \n \n Using an integrated port cluster. \n Added to a workstation through the use of an internal expansion card (PCIe, PCI, or mini-PCIe). \n Through the use of an externally connected card, such as USB or PCMCIA. \n 使用集成端口集群。 通過使用內部擴展卡（PCIe，PCI或mini-PCIe）添加到工作站。 通過使用外部連接的卡，例如USB或PCMCIA。 \n \n There are two main types of network adapters: wired and wireless. The wired cards support various cable types, such as unshielded twisted pair (UTP), fiber optic, and coaxial cabling. These various cable types are called media. \n 網絡適配器有兩種主要類型：有線和無線。 有線卡支持各種電纜類型，例如非屏蔽雙絞線（UTP），光纖和同軸電纜。 這些各種電纜類型稱為媒體。 \n Media \n Media is the term used to categorize the physical connection between two device ports, such as between a computer and a switch. Media is made up of copper cable, fiber-optic cable, or even radio frequency waves (as used in Wi-Fi networks). Media varies greatly in cost, from free for radio waves, to cheap for unshielded twisted pair (copper cable), to expensive for fiber-optic cabling. The type of media determines the bandwidth speed, capacity, and distance limitations for a particular network. We will discuss media in more depth in a future module. \n 媒體是用於對兩個設備端口之間（例如計算機和交換機之間）的物理連接進行分類的術語。 介質由銅纜，光纜甚至射頻波（用於Wi-Fi網絡）組成。 介質的成本差異很大，從無線電波的免費成本到非屏蔽雙絞線（銅纜）的價格便宜，再到光纖電纜的價格昂貴。 媒體的類型確定特定網絡的帶寬速度，容量和距離限制。 我們將在以後的模塊中更深入地討論媒體。 \n \n \n', 'tags': '', 'url': 'pch 10 Network Devices.html'}, {'title': 'pch 9 Network Defined by Topology', 'text': '\n overview \n \n In this module, we are going to cover the various types of networks, including local area networks \n 在本模塊中，我們將介紹各種類型的網絡，包括局域網 \xa0wide area networks, personal area networks, and metropolitan area networks.   廣域網，個人區域網和城域網。  next,we will cover the various network relationships, such as client/server and peer-to-peer,  and focus on the types of resources our networks use. \xa0接下來，我們將介紹各種網絡關係，例如客戶端/服務器和對等網絡，並集中討論網絡使用的資源類型。   Finally, we will talk about the topologies of our networks, such as the bus, the ring,  the star, the full mesh, and hybrid network topologies. 最後，我們將討論網絡的拓撲，例如總線，環形，星形，全網格和混合網絡拓撲。   \n \n Network Defined By Geography \n \n Networks are defined by the geography they cover. \n 網絡由其所覆蓋的地理位置定義。 \n We start with the area around a single person, with this area being termed the personal area network (PAN). \n 我們從一個人周圍的區域開始，將該區域稱為個人區域網絡（PAN）。 \n \xa0Next, we expand outward to the local area network (LAN), which can contain an entire office floor or building. \n 接下來，我們向外擴展到局域網（LAN），該局域網可以包含整個辦公樓層或建築物。 \n Moving outward again, we have the metropolitan area network, which covers the area across the city by connecting multiple LANs together.\xa0 \n 再次向外移動，我們有了城域網，該城域網通過將多個LAN連接在一起而覆蓋了整個城市。 \n \xa0Finally, we have the wide area network (WAN). This is the largest network we define by geography and it can go across the country or even across the world.\xa0 \n 最後，我們有了廣域網（WAN）。 這是我們按地理位置定義的最大網絡，它可以遍及全國，甚至遍及全球。 \n \xa0A great example of a WAN is the Internet, since it connects many networks together and stretches across the globe. \n WAN就是一個很好的例子，因為Internet將許多網絡連接在一起並遍及全球。 \n \n Perso nal Area Network \n A PAN has a very small range limited to just a few meters.\xa0 \n WAN就是一個很好的例子，因為Internet將許多網絡連接在一起並遍及全球。 \n If you stretch your hands out at your sides and spin around in a circle, this is the physical range of most PANs.\xa0 \n 如果您將雙手伸向兩側並轉一圈，則這是大多數PAN的物理範圍。 \n \xa0Bluetooth is one of the main things we use to create a PAN, although USB and infrared can also be used for these networks. \n 藍牙是我們用於創建PAN的主要內容之一，儘管USB和紅外也可以用於這些網絡。 \n Bluetooth has a range between one meter and 100 meters depending on which class of Bluetooth you are using,\xa0 \n 藍牙的範圍在1米至100米之間，具體取決於您所使用的藍牙類別， \n but most common Bluetooth devices are class two devices limited to 10 meters.\xa0 \n 但最常見的藍牙設備是限於10米的二級設備。 \n Some good examples of PANs are the connection between a USB hard drive and a laptop, \n PAN的一些很好的例子是USB硬盤驅動器和筆記本電腦之間的連接， \n or a Bluetooth cellphone connecting to your car stereo system wirelessly. \n \n \n \n 或藍牙手機無線連接到您的汽車立體聲系統。 \n \n \n Local\xa0 Area Network \n The next type of network defined by geography is the LAN,\xa0 \n \n 地理定義的下一種網絡類型是 LAN \n \n which stands for local area network.\xa0 \n 代表局域網。 \n The local area network is comprised of several devices that allow computers to connect to each other within a small geographic area. \n \n 局域網由幾個設備組成，這些設備使計算機可以在一個較小的地理區域內相互連接。 \n \n A LAN is, at its most basic, \n \n 局域網是最基本的 \n \n a connection of several workstations together using a hub,\xa0switch, or wireless access point. \n \n \xa0 使用集線器將多個工作站連接在一起，交換機或無線接入點。 \n \n LANs have a limited distance associated with them, with each network segment usually limited to 100 meters or less. \n \n 局域網的距離有限，每個網段通常限制在100米或更短。 \n \n Generally, a LAN is used to network the floor of an office, or possibly the entire office building in smaller networks. \xa0 \n \n 通常，LAN用於將辦公室地板或較小網絡中的整個辦公樓聯網。 \n \n \xa0LANs are generally connected in either a wired or wireless manner. \n \n \xa0 LAN 通常以有線或無線方式連接。 \xa0 \n \n If wired, they are connected using unshielded twisted pair cable using the Ethernet (IEEE 802.3) standard; \n \n 如果已連接，則使用符合以太網（IEEE 802.3）標準的非屏蔽雙絞線電纜進行連接； \n \n if wireless, they are connected using Wi-Fi radio signal (IEEE 802.11) standards. \n \n 如果為無線，則它們使用Wi-Fi無線電信號（IEEE 802.11）標准進行連接。 \n \n \n \n \n Metropolitan Area Networks \n Another way we can geographically define our networks is as a MAN. \n 我們可以在地理上定義網絡的另一種方法是將其作為MAN。 \n A metropolitan area network connects scattered locations across the city or county. \n 城域網連接整個城市或縣的分散位置。 \n \xa0This covers a larger geographical area than a local area network, but also a much smaller area than a wide-area network. \n 這比局域網覆蓋更大的地理區域，但是比廣域網覆蓋的區域小得多。 \n \n \n Wide Area Networks \n The WAN is used to connect network components that are geographically separated over vast distances together. \n WAN用於將地理位置遙遠的網絡組件連接在一起。 \n An example of a WAN would be to connect an office in Los Angeles to another corporate office in New York.\xa0 \n WAN的一個示例是將洛杉磯的辦公室連接到紐約的另一公司辦公室。 \n This can be done using virtual private networks (VPNs) over the Internet or using dedicated leased lines that would physically connect the city pairs together.\xa0 \n 可以使用Internet上的虛擬專用網絡（VPN）或將城市對實際連接在一起的專用租用線路來完成。 \n Regardless of the method of connection,\xa0 \n 無論採用哪種連接方式， \n once the two local area networks from Los Angeles and New York are connected, \n 一旦將洛杉磯和紐約的兩個局域網連接起來， \n they become part of the larger wide area network topology. \n它們成為更大的廣域網拓撲的一部分。 \n \n In addition to defining networks by geography or how much area they cover, you can also define them by the way they allocate their resources. The first method is what we call a client/server model. In a client/server model, a dedicated server or servers provide(s) access to files, scanners, printers, and other resources to client workstations. This simplifies the administration and backup burden, making the network centrally administered, and can provide better security because resources can be allocated according to job function, network privilege, or department, since all of the resources are located on a few key servers. The second way of sharing resources on the network is called the peer-to-peer model. In the peer-to-peer model, all workstations are considered equals: each computer or workstation shares its resources directly with the other workstations. There is no central administration. For example, if I shared my printer with my coworkers, then each time my coworker printed a document, it would be sent to the printer through my workstation. The drawback to this is that if my computer is turned off, my coworkers lose access to my resources, such as my printer. The administration and backup under the peer-to-peer model is much more difficult, since resources are located on numerous workstations across the network, making administrative tasks burdensome. Furthermore, there is no real way of securing network resources when allowing access between nodes or workstations. The benefit of peer-to-peer resource sharing is the low cost of entry, since no dedicated servers or specialized operating systems are required to share the resources. \n \n 除了按地理位置或網絡覆蓋範圍定義網絡外，您還可以通過分配資源的方式來定義網絡。第一種方法就是我們所說的客戶/服務器模型。在客戶端/服務器模型中，一個或多個專用服務器向客戶端工作站提供對文件，掃描儀，打印機和其他資源的訪問。由於所有資源都位於幾個關鍵服務器上，因此可以根據作業功能，網絡特權或部門分配資源，這簡化了管理和備份負擔，使網絡可以集中管理，並且可以提供更好的安全性。在網絡上共享資源的第二種方法稱為對等模型。在對等模型中，所有工作站都被認為是相等的：每台計算機或工作站直接與其他工作站共享其資源。沒有中央管理。例如，如果我與同事共享打印機，那麼每次同事打印文檔時，該文檔都會通過工作站發送到打印機。這樣做的缺點是，如果關閉計算機，我的同事將無法訪問我的資源，例如打印機。對等模型下的管理和備份要困難得多，因為資源位於網絡上的眾多工作站上，使管理任務變得很繁重。此外，當允許節點或工作站之間進行訪問時，沒有真正的方法來保護網絡資源。對等資源共享的好處是入門成本低，因為不需要專用服務器或專用操作系統來共享資源。 \n \n Besides geography and relationships, we can also define our networks by their topology. When we define our networks by their topology, we consider both the physical and logical topology, and both of these topologies do not have to match for a single network. The physical topology determines how the devices are physically connected, while the logical topology determines how the traffic flows across the network in a logical manner. There are many types of topologies, including bus, ring, star, full mesh, and hybrid. Currently, the most widely used model is a physical star and a logical bus topology using Ethernet. \n \n 除了地理和關係之外，我們還可以通過其拓撲定義網絡。 當我們通過拓撲定義網絡時，我們會同時考慮物理和邏輯拓撲，並且這兩種拓撲都不必針對單個網絡進行匹配。 物理拓撲決定了設備的物理連接方式，而邏輯拓撲決定了流量如何以邏輯方式流經網絡。 拓撲類型很多，包括總線，環形，星形，全網格和混合拓撲。 當前，使用最廣泛的模型是使用以太網的物理星形和邏輯總線拓撲。 \n \n \n \n \n B us Topology \n \n \n \n Bus topology typically uses a single cable running through the area that needs network connectivity, with each device that wishes to connect to the network tapping into that cable. The devices tap into the cable using either a T connector (see diagram below) or a vampire tap. A vampire tap is actually a type of connection where a metal tooth bites into the cable, making a physical connection with the copper wire running inside the cable. While bus topology is an older technology and not commonly used anymore, physically, it can still be found as a logical implementation in some instances. \n \n 總線拓撲通常使用一根電纜穿過需要網絡連接的區域，每個希望連接到網絡的設備都通過該電纜連接。 設備使用T型連接器（請參見下圖）或吸血鬼抽頭插入電纜。 吸血鬼抽頭實際上是一種連接，其中金屬齒咬入電纜，與在電纜內部延伸的銅線進行物理連接。 儘管總線拓撲是一種較舊的技術，在物理上已不再使用，但在某些情況下仍可以將其作為邏輯實現。 \n \n \n \n \n \n \n Ring Topology \n Ring topology typically uses a cable running in a circular loop, with each device connected to the ring. Data travels in a single direction around the ring. The most common use of ring topology is with backbone fiber networks. Fiber distributed data interface (FDDI) is a set of standards for transmitting data on fiber-optic lines in a LAN. FDDI commonly uses two counter-rotating rings to provide more redundancy. Each device waits its turn to communicate on the ring by passing a token around the ring. Therefore, ring topology networks are also called token ring networks. As there are two counter-rotating rings, FDDI tends to provide a little more redundancy than a standard bus topology. However, both bus and ring topologies were quickly replaced in most LANs by the star topology. \n 環形拓撲通常使用以環形迴路運行的電纜，每個設備都連接到環形。 數據在環上沿單個方向傳播。 環形拓撲最常見的用途是與骨幹光纖網絡一起使用。 光纖分佈式數據接口（FDDI）是用於在LAN中的光纖線上傳輸數據的一組標準。 FDDI通常使用兩個反向旋轉的環來提供更多的冗餘。 每個設備都通過在令牌環周圍傳遞令牌來等待其在令牌環上進行通信。 因此，環形拓撲網絡也稱為令牌環網絡。 由於有兩個反向旋轉的環，因此FDDI傾向於提供比標準總線拓撲更多的冗餘。 但是，在大多數LAN中，總線和環形拓撲都很快被星形拓撲取代。 \n \n Full Mesh Topology \n To deal with the issue of redundancy, the full mesh topology was created. This topology is by far the most redundant, and expensive, topology because every node or workstation in the network is directly connected to every other node. While this provides optimal routing, it is very expensive to maintain and operate. The number of connections required for any number of nodes can be calculated by using the formula, x = n(n-1)/2. For example, if you have six nodes, that would require 15 cables to connect them all to each other. If you had 50 nodes, that would require 1225 separate connections. You can certainly see why this topology is almost never used for local area networks, as the number of machines would drive the number of connections up too quickly. \n 為了解決冗餘問題，創建了全網狀拓撲。 到目前為止，此拓撲是最冗餘，最昂貴的拓撲，因為網絡中的每個節點或工作站都直接連接到每個其他節點。 儘管這提供了最佳的路由，但維護和操作非常昂貴。 可以使用公式x = n（n-1）/ 2計算任意數量的節點所需的連接數。 例如，如果您有六個節點，則需要15條電纜才能將它們彼此連接。 如果您有50個節點，則需要1225個單獨的連接。 您當然可以看到為什麼幾乎不將該拓撲用於局域網的原因，因為計算機數量過多會導致連接數量增加過快。 \n \n Partial Mesh Topology \n To solve the cost issues created by the full mesh topology, engineers created the partial mesh topology. Partial mesh topology is really a hybrid full mesh topology. It provides redundancy and optimal routing between some sites, while avoiding the expense of connecting every single site. In order to create this successfully, though, you must consider the network traffic patterns to design it efficiently. \n 為了解決由全網格拓撲創建的成本問題，工程師創建了部分網格拓撲。 部分網狀拓撲實際上是混合全網狀拓撲。 它提供了某些站點之間的冗餘和最佳路由，同時避免了連接每個站點的開銷。 但是，為了成功創建它，必須考慮網絡流量模式以進行有效設計。 \n If we have two sites which are very busy, such as Los Angeles, CA and New York, NY, we may want to provide them with additional redundancy by connecting them to a third city, such as Washington, DC. But a slower site, maybe somewhere like Greenville, SC, might only need to be connected to one of those three sites and can then use that as a jumping off point to connect to the other two sites. This works very similar to our air travel system, where we connect the large cities together directly, and we avoid direct flights to small cities. For example, if someone wanted to fly from Greenville to Los Angeles they would first take a flight from Greenville to Washington DC, then a direct flight on a larger plane to Los Angeles from Washington. \n 如果我們有兩個非常繁忙的站點，例如加利福尼亞的洛杉磯和紐約州的紐約，我們可能希望通過將它們連接到第三個城市（例如華盛頓特區）為他們提供更多的冗餘。 但是，速度較慢的站點（例如，南卡羅來納州格林維爾）可能僅需要連接到這三個站點之一，然後可以將該站點用作連接其他兩個站點的起點。 這與我們的航空旅行系統非常相似，在航空旅行系統中，我們將大城市直接連接在一起，並且避免了直接飛往小城市的航班。 例如，如果有人想從格林維爾飛往洛杉磯，他們會先從格林維爾飛往華盛頓特區，然後再乘較大的飛機直接從華盛頓飛往洛杉磯。 \n The same concept applies in a partial mesh topology. Partial mesh adds additional resources (connections) between the biggest and busiest sites, while still providing the smaller sites with minimal service to one of the large hub sites. The smaller site uses the large hub as a jumping off point to the rest of the network. \n 相同的概念適用於部分網格拓撲。 部分網狀網絡在最大和最繁忙的站點之間增加了額外的資源（連接），同時仍為大型樞紐站點之一提供較小的站點，但服務卻最少。 較小的站點將大型集線器用作連接到網絡其餘部分的起點。 \n \n \n \n \n \n \n', 'tags': '', 'url': 'pch 9 Network Defined by Topology.html'}, {'title': '剪刀石頭布試玩', 'text': "\n \n from flask import Flask\napp = Flask(__name__)\n \n@app.route('/')\ndef hello_world():\n    return 'Hello, World!'\n \napp.run(host='127.0.0.1', port=5000) \n \n \n", 'tags': '', 'url': '剪刀石頭布試玩.html'}]};